(* --------------------------------------------------------------------------------------------------------- *)
(* DIDComm *)
(* This is the full version of the protocol, where we send the encrypted resource and then the key once we receives the right signature *)
(* --------------------------------------------------------------------------------------------------------- *)
(* Start Definitions *)
(* --------------------------------------------------------------------------------------------------------- *)

(* Types Definition *)
type SymmetricKey.  (* Symmetric Keys *)
type SecretKey.     (* Secret Keys *)
type PublicKey.     (* Public Keys*)
type G.             (* Generator *)
type exponent.      (* Exponent *)
type DID.           (* DID *)

(* Tags Definition *)
type tag.   (* Tag for message *)
type ktag.  (* Tag for symmetric key *)
type stag.  (* Tag for signature *)
type etag.  (* Tag for exponent *)

(* Tags for the encapsulation of the messages in plaintext *)
const tag_m1, tag_m2, tag_m3, tag_m4, tag_m5, tag_h1, tag_h2, tag_h3, tag_m6, tag_m7, tag_m8, tag_m9:tag [data].

(* Tags for the transmission of the messages *)
const tag_M1, tag_M2, tag_M3, tag_M4, tag_M5, tag_H1, tag_H2, tag_H3, tag_M6, tag_M7, tag_M8, tag_M9:tag [data].

(* Tags for the encryption of symmetric key messages - for the single message *)
const tag_k0, tag_k1, tag_k2, tag_k3, tag_k4, tag_k5, tag_k6, tag_k7, tag_k8, tag_k9, tag_k10, tag_k11: ktag[data].

const tag_vpr, tag_vp, tag_vc, tag_pack_vpr_2, tag_sig_vpr_2, tag_vpr_fromu, tag_vpr_send, tag_vpr_send_app, tag_vp_fromu, tag_resource:tag[data].

const tag_enc_m1, tag_enc_m2, tag_enc_m3, tag_enc_m4, tag_enc_h1, tag_enc_h2, tag_enc_h3, tag_enc_m5, tag_enc_m6, tag_enc_m7, tag_enc_m7_wrap, tag_enc_m8, tag_enc_m9: tag[data].

const tag_th_3, tag_th_2, tag_th_0, tag_th_1, tag_n_c, tag_n_r, tag_rule, tag_did_i, tag_did_u, tag_did_a, tag_did_v, tag_uri, tag_vc_fromuser, tag_sig_vpr_fromapp, tag_sig_vp_user: tag[data].


(* Tags for the generation of symmetric key from generator *)
const tag_k_g2a2su, tag_k_g2sa2su, tag_k_g2v2sav, tag_k_g2sc2sav:tag[data].

(* Tags for the asymmetric encryption of generators *)
const tag_g2su, tag_g2sa, tag_g2sav, tag_g2sc:tag[data].

(* Tags for the signature of generators *)
const tag_sig_g2su, tag_sig_g2sa, tag_sig_g2sav, tag_sig_g2sc:tag[data].
(* Constants needed *)
const uri_req:bitstring.    (* URI of the request *)
const g: G.                 (* Generator for the g^x *)
const attr:bitstring.       (* The attribute of VC *)

(* One-Way Functions *)
fun hash_pk(PublicKey): bitstring.      (* Hash of PublicKey *)
fun Gtb(G):bitstring.                   (* Generator to obtain a bitstring *)
fun hash(bitstring): bitstring.         (* Hash of bitstring*)
fun pk(SecretKey):PublicKey.            (* Public Key Function *)
fun btk(bitstring): SymmetricKey.       (* Bitstring to SymmetricKey *)

(* Functions *)

(* Exponent *)
fun exp(G, exponent): G.
equation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).

(* Symmetric Encryption *)
fun senc(bitstring, SymmetricKey):bitstring.
reduc forall msg:bitstring,symk:SymmetricKey; sdec(senc(msg,symk),symk)=msg.


(* Symmetric Key Symmetric Encryption *)
fun sksenc(SymmetricKey, SymmetricKey):bitstring.
reduc forall msg:SymmetricKey,symk:SymmetricKey; sksdec(sksenc(msg,symk),symk)=msg.

(* Generator Asymmetric Encryption *)
fun aenc(bitstring, PublicKey):bitstring.
reduc forall msg:bitstring,sk:SecretKey; adec(aenc(msg,pk(sk)),sk)=msg.

(* Classical Digital Signature *)
fun sig(bitstring, SecretKey):bitstring.
reduc forall msg:bitstring,sk:SecretKey; check(msg,sig(msg,sk),pk(sk))=true.

(* Digital Signature of a Symmetric Key *)
fun sig_hash_k(SymmetricKey, SecretKey):bitstring.
reduc forall msg:SymmetricKey,sk:SecretKey; check_hash_k(msg,sig_hash_k(msg,sk),pk(sk))=true.

(* Function for Generating DIDs from Generator *)
fun gen_DID(G (*such that DID can not be inferred by others*)):DID.

(* Channel for the defense *)
fun ch(bitstring): channel.         (* Messages channel *)
fun chSymK(SymmetricKey): channel.  (* SymmetricKey channel *)


(* Secrecy *)
free vp_fromProver: bitstring [private].            (* VP Released by the Prover *)
free resource_fromVerifier: bitstring [private].    (* Resource released by the Verifier *)
free resource_fromApp: bitstring [private].         (* Resource released by the App *)
const attr_did_i, attr_did_u: bitstring[private].

(* Authentication *)

(* User authenticate the App *)
event auth_UserCompletesProtocolWithApp(bitstring).
event auth_AppSendsLastMessageToUser(bitstring).

event reachEndUser(bitstring, bitstring, bitstring, bitstring, bitstring).
event reachEndApp(bitstring, bitstring, bitstring, bitstring, bitstring, bitstring, bitstring, bitstring, bitstring, bitstring, bitstring, bitstring).
event reachEndCSS(bitstring, bitstring, bitstring, bitstring, bitstring, bitstring, bitstring).

event reach.

(* --------------------------------------------------------------------------------------------------------- *)
(* End Definitions *)
(* Start Agent Macros *)
(* --------------------------------------------------------------------------------------------------------- *)

let user(talksOnlyToHonest:bool,  c_u2a:channel, DID_u:DID, u:exponent, sku:SecretKey, DID_a:DID, pka:PublicKey, g2a:G, DID_v:DID, pkv:PublicKey,  g2v:G, vc:bitstring, uri_req:bitstring) =
    
    in(c_u2a, (=tag_th_2, th_2:bitstring));
   
    (* Message H1 User -> App *)
    (* h1 = sig(g^su, sku) *)
    new su: exponent;
    new th_3:bitstring;
    let g2su = exp(g, su) in
    let g2a2su = exp(g2a, su) in
    let k_g2a2su = btk((tag_k_g2a2su, g2a2su)) in
    new k5:SymmetricKey;
    let h1 = ((tag_th_2, th_2), (tag_th_3, th_3), sig(hash((tag_sig_g2su, Gtb(g2su))),sku)) in
    let H1 = (tag_h1, aenc((tag_g2su, g2su), pka), senc((tag_k5, k5), k_g2a2su), senc((tag_enc_h1, h1), k5)) in
    out(c_u2a, (tag_H1, H1));

    (* Message H2 App -> User *)
    (* h2 = sig(g^sa, ska) *)
    in(c_u2a, (=tag_H2, H2:bitstring));
    let (=tag_h2, enc_g2sa: bitstring, enc_k6: bitstring, enc_h2:bitstring) = H2 in
    let (=tag_g2sa, g2sa:G) = adec(enc_g2sa, sku) in
    let g2sa2su = exp(g2sa, su) in
    let k_g2sa2su = btk((tag_k_g2sa2su, g2sa2su)) in (* The tag used tag_k_g2su2sa is reverted with respect to the construction because otherwise it will not work *)
    let (=tag_k6, k6:SymmetricKey) = sdec(enc_k6, k_g2sa2su) in
    let (=tag_enc_h2, h2:bitstring) = sdec(enc_h2, k6) in 
    let ((=tag_th_3, th_3':bitstring), sig_g2sa:bitstring) = h2 in
    if th_3' = th_3 then
    if check(hash((tag_sig_g2sa, Gtb(g2sa))), sig_g2sa, pka) then

    (* Message H3 User -> App *)
    (* h3 = th_id, ack *)
    new k7: SymmetricKey;
    new ack:bitstring;
    let h3:bitstring = (tag_enc_h3, ack) in
    let enc_k7 = senc((tag_k7, k7), k_g2sa2su) in
    let H3 = (tag_h3, enc_k7, senc(h3, k7)) in
    out(c_u2a,(tag_H3, H3));
    
    (* Message 6 App -> User *)
    (* This is the VPR sent by the Verifier to the App, and then signed by the App for the User *)
    in(c_u2a, (=tag_M6, M6:bitstring));
     
    let (=tag_m6, enc_k8:bitstring, enc_m6:bitstring) = M6 in
    let (=tag_k8, k8:SymmetricKey) = sdec(enc_k8, k_g2sa2su) in
    let (=tag_enc_m6, m6:bitstring) = sdec(enc_m6, k8)  in
    let (vpr_2:bitstring, (=tag_sig_vpr_fromapp, sig_vpr_2:bitstring)) = m6 in
    let (=tag_pack_vpr_2, m5':bitstring, (=tag_n_r, n_r':bitstring)) = vpr_2 in
    let (=tag_vpr_send_app, (=tag_rule, rule':bitstring), (=tag_n_c, n_c':bitstring)) = m5' in
    let (=tag_vpr, (=tag_did_i, DID_i':DID), (=tag_did_v, DID_v':DID), (=tag_did_u, DID_u':DID), (=tag_did_a, DID_a':DID), (=tag_uri, uri':bitstring)) = rule' in
    (* Check if the signature applied by the App is genuine *)
    if (check(hash(vpr_2), sig_vpr_2, pka)) then
    (* Check that these are field we expect to sign  *)
    if ((DID_v', DID_u', DID_a', uri') = (DID_v, DID_u, DID_a, uri_req)) then  (*Who knows, maybe server is starting behaving maliciously *)
    
    
    (* Message 7 User -> App *)
    (* Produce the VP as response to the VPR *)
    let vp = ((tag_n_r, n_r'), (tag_vpr_fromu, (tag_n_c, n_c')), (tag_vc_fromuser, vc)) in
    let m7 = (tag_vp_fromu, (tag_vp, vp), (tag_sig_vp_user, sig(hash(vp), sku))) in
    new k9:SymmetricKey;
    let M7 = (tag_m7, senc((tag_k9, k9), k_g2sa2su), senc((tag_enc_m7, m7), k9)) in
    out(c_u2a, (tag_M7, M7));

    event reachEndUser(H1, H2, H3, M6, M7);
    if talksOnlyToHonest then
        event auth_UserCompletesProtocolWithApp(m6)|
        out(ch(vp), vp_fromProver);
    
    0.

let app(talksOnlyToHonest:bool, c_a2v:channel, c_u2a:channel, DID_a:DID, a:exponent, ska:SecretKey,  DID_u:DID, pku:PublicKey, g2u:G, DID_v:DID, pkv:PublicKey, g2v:G, DID_i:DID, pki:PublicKey ,uri:bitstring) =

    (* Message th0 CSS -> App *)
    in(c_a2v, (=tag_th_0, th_0:bitstring));
    (* Message 1 App -> CSS *)
    (* m1 = (g^sav, sig(g^sav, ska))*)
    new sav: exponent;
    let g2sav = exp(g, sav) in
    let g2v2sav = exp(g2v, sav) in
    let k_g2v2sav = btk((tag_k_g2v2sav, g2v2sav)) in
    new k0:SymmetricKey;
    new th_1:bitstring;
    let sig_g2sav = sig(hash((tag_sig_g2sav, Gtb(g2sav))), ska) in
    let m1 = ((tag_th_0, th_0), (tag_th_1, th_1), sig_g2sav) in
    let M1 = (tag_m1, aenc((tag_g2sav, g2sav), pkv), senc((tag_k0, k0), k_g2v2sav), senc((tag_enc_m1, m1), k0)) in
    out(c_a2v, (tag_M1,M1));

    (* Message 2 CSS -> App *)
    (* m2 = (g^sc, sig(g^sc, skv))*)
    in(c_a2v, (=tag_M2, M2:bitstring));
    let (=tag_m2, enc_g2sc: bitstring, enc_k1: bitstring, enc_m2:bitstring) = M2 in
    let (=tag_g2sc, g2sc:G) = adec(enc_g2sc, ska) in
    let g2sc2sav = exp(g2sc, sav) in
    let k_g2sc2sav = btk((tag_k_g2sc2sav, g2sc2sav)) in (* The tag used tag_k_g2sav2sc is reverted with respect to the construction because otherwise it will not work *)
    let (=tag_k1, k1:SymmetricKey) = sdec(enc_k1, k_g2sc2sav) in
    let (=tag_enc_m2, m2:bitstring) = sdec(enc_m2, k1) in
    let ((=tag_th_1, th_1':bitstring), sig_g2sc:bitstring) = m2 in
    if (th_1' = th_1) then
    if check(hash((tag_sig_g2sc, Gtb(g2sc))), sig_g2sc, pkv) then

    (* Message 3 App -> CSS *)
    (* Send ack to the CSS *)
    new k2: SymmetricKey;
    new ack_a2v:bitstring;
    let m3:bitstring = ack_a2v in
    let M3 = (tag_m3, senc((tag_k2, k2), k_g2sc2sav), senc((tag_enc_m3, m3), k2)) in
    out(c_a2v,(tag_M3, M3));

    (* Message 4 App -> CSS *)
    (* m4 = (i, v, u, uri, a) *)
    
    new k3: SymmetricKey;
    let m4 = (DID_i, DID_v, DID_u, DID_a) in
    let M4 = (tag_m4, senc((tag_k3, k3), k_g2sc2sav), senc((tag_enc_m4, m4), k3)) in
    out(c_a2v,(tag_M4, M4)); 

    event reach;
    (* Message 5 CSS -> App *)
    (* Receive m5 = (v, rule, n_v) from the CSS *)
    
    in(c_a2v, (=tag_M5, M5:bitstring));
    let (=tag_m5, enc_k4:bitstring, enc_m5:bitstring) = M5 in
    let (=tag_k4, k4:SymmetricKey) = sdec(enc_k4, k_g2sc2sav) in
    let (=tag_enc_m5, m5:bitstring) = sdec(enc_m5, k4)  in
    let ((=tag_rule, rule':bitstring), (=tag_n_c, n_c:bitstring)) = m5 in
  
    let (=tag_vpr, (=tag_did_i, DID_i':DID), (=tag_did_v, DID_v':DID), (=tag_did_u, DID_u':DID), (=tag_did_a, DID_a':DID)) = rule' in  
    if ((DID_i', DID_v', DID_u', DID_a') = (DID_i, DID_v, DID_u, DID_a)) then  (*Who knows, maybe server is starting behaving maliciously *)
    

    new th_2:bitstring;
    out(c_u2a, (tag_th_2, th_2)); 
 
    (* Message H1 User -> App *)
    (* h1 = g^su, sig(g^su, sku) *)
    in(c_u2a, (=tag_H1, H1:bitstring));
    let (=tag_h1, enc_g2su: bitstring, enc_k5:bitstring, enc_h1:bitstring) = H1 in
    let (=tag_g2su, g2su:G) = adec(enc_g2su, ska) in
    let g2su2a = exp(g2su, a) in
    let g2a = exp(g, a) in
    let k_g2su2a = btk((tag_k_g2a2su, g2su2a)) in (* The tag used tag_k_g2a2su is reverted with respect to the construction because otherwise it will not work *)
    let (=tag_k5, k5:SymmetricKey) = sdec(enc_k5, k_g2su2a) in
    let (=tag_enc_h1, h1:bitstring) = sdec(enc_h1, k5) in
    let ((=tag_th_2, th_2':bitstring), (=tag_th_3, th_3:bitstring), sig_g2su:bitstring) = h1 in
    if th_2 = th_2' then
    if check(hash((tag_sig_g2su, Gtb(g2su))), sig_g2su, pku) then
     

    (* Message H2 App -> User *)
    (* h2 = g^sa, sig(g^sa, ska) *)
    new sa: exponent;
    let g2sa = exp(g, sa) in
    let g2su2sa = exp(g2su, sa) in
    let k_g2su2sa = btk((tag_k_g2sa2su, g2su2sa)) in
    new k6:SymmetricKey;
    let h2 = ((tag_th_3, th_3), sig(hash((tag_sig_g2sa, Gtb(g2sa))), ska)) in
    let H2 = (tag_h2, aenc((tag_g2sa, g2sa), pku), senc((tag_k6, k6), k_g2su2sa), senc((tag_enc_h2, h2), k6)) in 
    event auth_AppSendsLastMessageToUser(H2);
    out(c_u2a, (tag_H2, H2));

    (* Message H3 User -> App *)
    in(c_u2a, (=tag_H3, H3:bitstring));
    let (=tag_h3, enc_k7:bitstring, enc_h3:bitstring) = H3 in
    let (=tag_k7, k7:SymmetricKey) = sdec(enc_k7, k_g2su2sa) in
    let (=tag_enc_h3, ack_u:bitstring) = sdec(enc_h3, k7) in

    
    (* Message 6 App -> User *)
    new n_r:bitstring;
    let rule'':bitstring = (tag_vpr, (tag_did_i, DID_i), (tag_did_v, DID_v), (tag_did_u, DID_u), (tag_did_a, DID_a), (tag_uri, uri)) in
    
    let vpr_2 = (tag_pack_vpr_2, (tag_vpr_send_app, (tag_rule, rule''), (tag_n_c, n_c)), (tag_n_r, n_r)) in
    let m6 = (vpr_2, (tag_sig_vpr_fromapp, sig(hash(vpr_2), ska))) in
    new k8:SymmetricKey;
    let enc_m6 = senc((tag_enc_m6, m6), k8) in
    let enc_k8 =  senc((tag_k8, k8), k_g2su2sa) in
    let M6 = (tag_m6, enc_k8, enc_m6) in
    event reach;
    event auth_AppSendsLastMessageToUser(m6);
    out(c_u2a, (tag_M6, M6)); 
    
    (* Message 7 User -> App *)
    in(c_u2a, (=tag_M7, M7:bitstring));
    let (=tag_m7, enc_k9:bitstring, enc_m7:bitstring) = M7 in
    let (=tag_k9, k9:SymmetricKey) = sdec(enc_k9, k_g2su2sa) in
    let (=tag_enc_m7, m7:bitstring) = sdec(enc_m7, k9) in
    let (=tag_vp_fromu, (=tag_vp, vp:bitstring), (=tag_sig_vp_user, sig_vp:bitstring)) = m7 in
    let ((=tag_n_r, n_r':bitstring), vpr':bitstring, (=tag_vc_fromuser, vc':bitstring)) = vp in
    let (=tag_vpr_fromu, (=tag_n_c, n_c'':bitstring)) = vpr' in
    let (=tag_vc, (attr':bitstring, DID_i'':DID, DID_u'':DID), sig_vc:bitstring) = vc' in
    if n_r = n_r'  then
    if (check(hash(vp), sig_vp, pku)) then
    

    (* Message 8 App -> CSS *)
    new k10:SymmetricKey;
    let m8 = (tag_enc_m7_wrap, (tag_enc_m7, (tag_vp, vp), (tag_sig_vp_user, sig_vp)), sig(hash((tag_enc_m7, vp, sig_vp)), ska)) in
    let M8 = (tag_m8, senc((tag_k10, k10), k_g2sc2sav), senc((tag_enc_m8, m8), k10)) in
    out(c_a2v, (tag_M8, M8));


    (* Message 9 CSS -> App *)
    in(c_a2v, (=tag_M9, M9:bitstring));
    let (=tag_m9, enc_k11:bitstring, enc_m10:bitstring) = M9 in
    let (=tag_k11, k11:SymmetricKey) = sdec(enc_k11, k_g2sc2sav) in
    let (=tag_enc_m9, resource:bitstring) = sdec(enc_m10, k11) in
    event reachEndApp(M1, M2, M3, M4, M5, H1, H2, H3, M6, M7, M8, M9);
    if talksOnlyToHonest then
        out(ch(resource), resource_fromApp);
    0.

let verifier(talksOnlyToHonest:bool,  c_a2v:channel, DID_v:DID, v:exponent, skv:SecretKey, DID_u:DID, pku:PublicKey, g2u:G, DID_a:DID, pka:PublicKey,  g2a:G, DID_i:DID, pki:PublicKey, uri_req:bitstring) =
               
    new th_0:bitstring;
    out(c_a2v, (tag_th_0, th_0));
    
    (* Message 1 App -> CSS *)
    (* m1 = sig(g^sav, ska) *)
    in(c_a2v, (=tag_M1, M1:bitstring));
    let (=tag_m1, enc_g2sav: bitstring, enc_k0:bitstring, enc_m1:bitstring) = M1 in
    let (=tag_g2sav, g2sav:G) = adec(enc_g2sav, skv) in
    let g2sav2v = exp(g2sav, v) in
    let g2v = exp(g, v) in
    let k_g2sav2v = btk((tag_k_g2v2sav, g2sav2v)) in (* The tag used tag_k_g2v2sav is reverted with respect to the construction because otherwise it will not work *)
    let (=tag_k0, k0:SymmetricKey) = sdec(enc_k0, k_g2sav2v) in
    let (=tag_enc_m1, m1:bitstring) = sdec(enc_m1, k0) in
    let ((=tag_th_0, th_0':bitstring), (=tag_th_1, th_1:bitstring), sig_g2sav:bitstring) = m1 in
    if (th_0' = th_0) then
    if check(hash((tag_sig_g2sav, Gtb(g2sav))), sig_g2sav, pka) then

    (* Message 2 CSS -> App *)
    (* m2 = sig(g^sc, skv) *)
    new sc: exponent;
    let g2sc = exp(g, sc) in
    let g2sav2sc = exp(g2sav, sc) in
    let k_g2sav2sc = btk((tag_k_g2sc2sav, g2sav2sc)) in
    new k1:SymmetricKey;
    let m2 = ((tag_th_1, th_1), sig(hash((tag_sig_g2sc, Gtb(g2sc))), skv)) in
    let M2 = (tag_m2, aenc((tag_g2sc, g2sc), pka), senc((tag_k1, k1), k_g2sav2sc), senc((tag_enc_m2, m2), k1)) in 
    out(c_a2v, (tag_M2, M2));

    (* Message 3 App -> CSS *)
    (* m3 = ack *)
    in(c_a2v, (=tag_M3, M3:bitstring));
    let (=tag_m3, enc_k2:bitstring, enc_m3:bitstring) = M3 in
    let (=tag_k2, k2:SymmetricKey) = sdec(enc_k2, k_g2sav2sc) in
    let (=tag_enc_m3, m3:bitstring) = sdec(enc_m3, k2) in

    (* Message 4 App -> CSS *)
    (* m4 = (i, v, u, uri, a) *)
    in(c_a2v, (=tag_M4, M4:bitstring));
    let (=tag_m4, enc_k3:bitstring, enc_m4:bitstring) = M4 in
    let (=tag_k3, k3:SymmetricKey) = sdec(enc_k3, k_g2sav2sc) in
    let (=tag_enc_m4, m4:bitstring) =  sdec(enc_m4,k3) in
    let (DID_i':DID, DID_v':DID, DID_u':DID, DID_a':DID) = m4 in
    if (DID_i', DID_v', DID_u', DID_a') = (DID_i, DID_v, DID_u, DID_a) then
    
    (* Message 5 CSS -> App *)
    (* m5 = (rule, n_c) *)
    new n_c:bitstring;
    let rule = (tag_vpr, (tag_did_i, DID_i), (tag_did_v, DID_v), (tag_did_u, DID_u), (tag_did_a, DID_a)) in
    let m5 = ((tag_rule, rule), (tag_n_c, n_c))  in
    new k4:SymmetricKey;
    let M5 = (tag_m5, senc((tag_k4, k4),k_g2sav2sc), senc((tag_enc_m5, m5), k4))  in
    out(c_a2v, (tag_M5, M5));
    
    (* Message 8 App -> CSS *)
    (* Receive the VP^2 and checks for the signature applied *)
    in(c_a2v, (=tag_M8, M8:bitstring));
    let (=tag_m8, enc_k10:bitstring, enc_m8:bitstring) = M8 in
    let (=tag_k10, k10:SymmetricKey) = sdec(enc_k10, k_g2sav2sc) in
    let (=tag_enc_m8, m8:bitstring) = sdec(enc_m8, k10) in
    let (=tag_enc_m7_wrap, m7':bitstring, sig_m7':bitstring) = m8 in
    let (=tag_enc_m7, (=tag_vp, vp:bitstring), (=tag_sig_vp_user, sig_vp:bitstring)) =  m7' in
    
    if (check(hash((tag_enc_m7, vp, sig_vp)), sig_m7', pka)) then
    if check(hash(vp), sig_vp, pku) then

    let ((=tag_n_r, n_r':bitstring), vpr':bitstring, (=tag_vc_fromuser, vc':bitstring)) = vp in
    let (=tag_vc, cred':bitstring, sig_cred':bitstring) = vc' in
    let (attr'':bitstring, DID_i'':DID, DID_u'':DID) = cred' in
    if check(hash(cred'), sig_cred', pki) then

    if (attr'', DID_i'', DID_u'') = (attr, DID_i, DID_u) then
    let (=tag_vpr_fromu, (=tag_n_c, n_c'':bitstring)) = vpr' in
    if (n_c'') = (n_c) then     
    (* Message 9 - CSS -> App *)
    (* Message containing the encrypted resource *)
    new k11: SymmetricKey;
    new resource: bitstring;
    let M9 = (tag_m9, senc((tag_k11, k11), k_g2sav2sc), senc((tag_enc_m9, resource), k11)) in
    out(c_a2v, (tag_M9, M9));
    event reachEndCSS(M1, M2, M3, M4, M5, M8, M9);
    if talksOnlyToHonest then
        out(ch(resource), resource_fromVerifier);
    0.

(* SECRECY *)

query M1:bitstring, M2:bitstring, M3:bitstring, M4:bitstring, M5:bitstring, H1:bitstring, H2:bitstring, H3:bitstring, M6:bitstring, M7:bitstring, M8:bitstring, M9:bitstring;
    event(reachEndUser(H1, H2, H3, M6, M7)) && event(reachEndApp(M1, M2, M3, M4, M5, H1, H2, H3, M6, M7, M8, M9)) && event(reachEndCSS(M1, M2, M3, M4, M5, M8, M9)).

query event(reach).

query m6:bitstring;
     event(auth_UserCompletesProtocolWithApp(m6)) ==> event(auth_AppSendsLastMessageToUser(m6)).

(* Define the channels *)
free c:channel.
free c_u2a:channel. (* For User - App*)
free c_a2v:channel. (* For App - Verifier *)

(* Definition for the attacker *)
free skE:SecretKey.
free E:exponent.

process (*use root process for setup *)


    (* Declare Secret Keys*)
    new sku:SecretKey;
    new ska:SecretKey;
    new skv:SecretKey;
    new ski:SecretKey;

    (* Declare Exponents *)
    new u:exponent;
    new a:exponent;
    new v:exponent;
    new i:exponent;

    (* Advertise Public Exponent (Generators)*)
    out(c, exp(g, u));
    out(c, exp(g, a));
    out(c, exp(g, v));
    out(c, exp(g, i));
    
    (* Advertise Public Keys *)
    out(c, pk(sku));
    out(c, pk(ska));
    out(c, pk(skv));
    out(c, pk(ski));


    (* Declare identities *)
    let DID_u = gen_DID(exp(g, u)) in
    let DID_a = gen_DID(exp(g, a)) in
    let DID_v = gen_DID(exp(g, v)) in
    let DID_i = gen_DID(exp(g, i)) in
    let DID_E = gen_DID(exp(g, E)) in

    (* Advertise identities*)
    out(c, DID_u);
    out(c, DID_a);
    out(c, DID_v);
    out(c, DID_i);
    out(c, DID_E);

    let vc = (tag_vc, (attr, DID_i, DID_u), sig(hash((attr, DID_i, DID_u)), ski)) in

    (*let agents dance*)
    (

        (!verifier(true,  c_a2v,  DID_v, v, skv, DID_u, pk(sku), exp(g,u), DID_a, pk(ska),  exp(g,a), DID_i, pk(ski), uri_req)) |
        (!app(true, c_a2v, c_u2a, DID_a, a, ska, DID_u, pk(sku), exp(g,u), DID_v, pk(skv), exp(g,v), DID_i, pk(ski), uri_req)) |
        (!user(true,  c_u2a, DID_u, u, sku, DID_a, pk(ska), exp(g,a), DID_v, pk(skv),  exp(g,v), vc, uri_req))
        (*(!app(false, c_a2v, c_u2a, DID_a, a, ska, DID_E, pk(skE), exp(g,E), DID_v, pk(skv),  exp(g,v), DID_i, pk(ski),uri_req)) |
        (!app(false, c_a2v, c_u2a, DID_a, a, ska, DID_E, pk(skE), exp(g,E), DID_E, pk(skE), exp(g,E), DID_i, pk(ski), uri_req)) |
        (!app(false, c_a2v, c_u2a, DID_a, a, ska, DID_u, pk(sku),  exp(g,u), DID_E, pk(skE), exp(g,E), DID_i, pk(ski), uri_req))*)
        (*(!verifier(false, c2, c3, v, exp_v, skv, e, pk(sk_E), exp(g,exp_E), a, pk(ska),  exp(g,exp_a), i, pk(ski),  ttp, pk(sk_ttp), exp(g,exp_ttp), uri_req)) |
        (!verifier(false, c2, c3, v, exp_v, skv, u, pk(sku),  exp(g,exp_u), e, pk(sk_E), exp(g,exp_E), i, pk(ski),  ttp, pk(sk_ttp), exp(g,exp_ttp), uri_req)) |
        (!verifier(false, c2, c3, v, exp_v, skv, e, pk(sk_E), exp(g,exp_E), e, pk(sk_E), exp(g,exp_E), i, pk(ski),  ttp, pk(sk_ttp), exp(g,exp_ttp), uri_req)) |
        (!verifier(false, c2, c3, v, exp_v, skv, u, pk(sku),  exp(g,exp_u), a, pk(ska),  exp(g,exp_a), e, pk(sk_E), ttp, pk(sk_ttp), exp(g,exp_ttp), uri_req)) |
        (!verifier(false, c2, c3, v, exp_v, skv, e, pk(sk_E), exp(g,exp_E), a, pk(ska),  exp(g,exp_a), e, pk(sk_E), ttp, pk(sk_ttp), exp(g,exp_ttp), uri_req)) |
        (!verifier(false, c2, c3, v, exp_v, skv, u, pk(sku),  exp(g,exp_u), e, pk(sk_E), exp(g,exp_E), e, pk(sk_E), ttp, pk(sk_ttp), exp(g,exp_ttp), uri_req)) |
        (!verifier(false, c2, c3, v, exp_v, skv, e, pk(sk_E), exp(g,exp_E), e, pk(sk_E), exp(g,exp_E), e, pk(sk_E), ttp, pk(sk_ttp), exp(g,exp_ttp), uri_req)) | 
        (!user(false, c, u, exp_u, sku, e, pk(sk_E), exp(g,exp_E), v, pk(skv),  exp(g,exp_v), vc, uri_req)) |
        (!user(false, c, u, exp_u, sku, a, pk(ska),  exp(g,exp_a), e, pk(sk_E), exp(g,exp_E), vc, euri)) |
        (!user(false, c, u, exp_u, sku, e, pk(sk_E), exp(g,exp_E), e, pk(sk_E), exp(g,exp_E), vc, euri)) |
        (!trustedThirdParty(false, c3, c4, ttp, exp_ttp, sk_ttp, e, pk(sk_E), exp(g,exp_E), v, pk(skv),  exp(g,exp_v))) |
        (!trustedThirdParty(false, c3, c4, ttp, exp_ttp, sk_ttp, a, pk(ska),  exp(g,exp_a), e, pk(sk_E), exp(g,exp_E))) |
        (!trustedThirdParty(false, c3, c4, ttp, exp_ttp, sk_ttp, e, pk(sk_E), exp(g,exp_E), e, pk(sk_E), exp(g,exp_E))) *)
    
    )

(* --------------------------------------------------------------------------------------------------------- *)
(* End Main *)
(* --------------------------------------------------------------------------------------------------------- *)